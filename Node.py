import random
# import time
import tensorflow as tf
from Field import Field
import numpy as np
from numpy.typing import NDArray
from NodeExecutors import make_executor
from cell_export_manager import array_to_cell_data


# This function is used by a node to create an 'assembly' for a field,
# which is a function that when called will gather values emitted into this field by this node's input edges.
def make_field_assembly(field_edges, field,
                        distance_scaling,
                        training_variable,
                        hot_node_id
                        ):

    def add_field_values(cell_op_state):
        emitted_inputs = tf.stack([edge.emitted_value for edge in field_edges])
        training_variable_slice, _ = tf.split(training_variable[hot_node_id, field.field_index], [len(field_edges), tf.shape(training_variable)[2] - len(field_edges)])
        clipped_scale_value = field.gather_field_graph_values(emitted_inputs, distance_scaling, training_variable_slice)
        cell_op_state[field.field_index] = clipped_scale_value

    # assemble_inputs.append(add_field_values)
    return add_field_values


class Node:
    def __init__(self, node_index, candidate_edges, generation_data: NDArray, field: Field,
                 max_field_edge_count, distance_scalings, is_start=False):
        """
         Represents a node in the graph.

         Args:
             node_index (int): The index of the node.
             candidate_edges (List[List[Node]]): All nodes that this node could potentially connect to, sorted into the
             candidate nodes' output fields.
             generation_data (NDArray): Serialized data generated by the genetic algorithm expressing the function of a node
             field (Field): The output field associated with the node.
             max_field_edge_count (int): The maximum number of edges, per field that this node can be assigned
             distance_scalings (NDArray): A scaling factor for node interactions based on distance
             is_start: Indicates whether this node is used to input data into the graph
         """
        self.index = node_index
        action_type, left_index, right_index, return_index, generation_state, position = (
            array_to_cell_data(generation_data))
        self.left_index = left_index
        self.right_index = right_index
        self.generation_data = generation_data
        self.position = position
        # Filters the candidate edges according to whether this node's computation relies on the value emitted from the considered edge
        self.edges = []
        self._output_field = field
        self._used = False
        # A record of the edges connected to this node by index - a subset of these will be used in tensor gather operations

        self.field_edge_length_scalings = []
        for field_index, field_edges in enumerate(candidate_edges):
            valid_field_edges = [edge for edge in field_edges if edge.is_valid]
            if 0 < len(valid_field_edges) and left_index == field_index:
                field_edge_selection_and_distances = self.size_and_filter_edges(
                    distance_scalings,
                    max_field_edge_count,
                    valid_field_edges
                )
                self.edges.append([field_edge_selection_and_distance[0]
                                   for field_edge_selection_and_distance in field_edge_selection_and_distances])
                self.field_edge_length_scalings.append([field_edge_selection_and_distance[1]
                                   for field_edge_selection_and_distance in field_edge_selection_and_distances])
            else:
                self.edges.append([])
                self.field_edge_length_scalings.append([])

        self._is_valid = is_start or all(
            0 < len(field_edges) for field_index, field_edges in enumerate(self.edges) if
            left_index == field_index or
            (-1 != right_index and right_index == field_index)
        )
        self.rank = 1 if (is_start or not self.is_valid) else 1 + max(field_edge.rank for field_edges in self.edges for field_edge in field_edges)

        self.emitted_value = None
        self.training_variable = tf.Variable(1.0)
        self.is_active = True
        self.test_re_added = []
        self.was_revived = False

    @property
    def field_edge_counts(self):
        return tuple(len(field_edges) for field_edges in self.edges)

    @property
    def is_valid(self):
        return self._is_valid

    @property
    def is_used(self):
        return self._used

    def check_still_active(self):
        self.is_active = self.is_active and all(
            0 < len([edge_node for edge_node in field_edges if edge_node.is_active]) for field_index, field_edges in enumerate(self.edges) if
            self.left_index == field_index or
            (-1 != self.right_index and self.right_index == field_index))

    def size_and_filter_edges(self, distance_scalings, max_edge_count, candidate_edges):
        edge_and_scaling = [[edge, distance_scalings[edge.index] / float(edge.rank)] for edge in candidate_edges]
        edge_and_scaling.sort(key=lambda e: e[1])
        selected_edges_and_distances = edge_and_scaling[-1 * max_edge_count:]
        return selected_edges_and_distances


    def mark_used_edges(self):
        """
        Marks the node as used, and returns
        :return: The edges in this node's computation if it was previously not marked as used, or an empty tuple if it had been previously marked
        had already been marked as used
        """
        if self._used:
            return tuple()
        else:
            self._used = True
            return tuple(edge for edge in self.flatten_edges())

    def flatten_edges(self):
        flattened_edges = [edge for field_edge in self.edges for edge in field_edge]
        return flattened_edges

    @property
    def output_field(self):
        return self._output_field

    def reset_usage(self, output_index=None):
        """
        Resets the usage status of the node based on its output field
        :param output_index: The index of the field output by the graph
        :return: The edges in this node's computation if it marked as used, or else an empty tuple
        """
        self._used = (output_index is None or output_index == self._output_field.field_index)
        if self._used:
            return tuple(edge for edge in self.flatten_edges())
        else:
            return tuple()

    def visited_field(self, field_index):
        """
        Provides a check if this node's computation relies on a given field
        :param field_index: The index of the field to check
        :return: The result of the check
        """
        return self.left_index == field_index or \
            (-1 != self.right_index and self.right_index == field_index)

    def make_node_eval(self, test_mode, fields, training_variable, hot_node_id, pruning_training_var):
        """
        Creates a function for evaluating the node.

        Args:
            test_mode (bool): True if the evaluation is in test mode, False otherwise.
            fields (List[Field]): The list of fields.

        Returns:
            Tuple: The computation performed by this node, and a list of trainable variables used to give feedback to the ecosystem.
        """
        assemble_inputs = []
        action_type, left_index, right_index, return_index, generation_state, position = (
            array_to_cell_data(self.generation_data))
        if right_index is None:
            right_field = None
        else:
            right_field = fields[right_index]
        node_op = make_executor(action_type, fields[left_index], right_field, fields[return_index], generation_state)
        # noinspection PyCallingNonCallable
        for field_edges, field, edge_length_scalings in zip(self.edges, fields, self.field_edge_length_scalings):
            active_edge_generator = [edge for edge in field_edges if edge.is_active]
            edge_count = len(active_edge_generator)
            if 0 < edge_count:
                expanded_distance_scaling = tf.expand_dims(
                    tf.gather(edge_length_scalings, [edge_index for edge_index, node in enumerate(field_edges) if node.is_active])
                    , 1)
                op = make_field_assembly(active_edge_generator, field,
                                         expanded_distance_scaling, training_variable, hot_node_id)
                assemble_inputs.append(op)


        if test_mode:
            def emit_node_value():
                action_data = (action_type, left_index, right_index, return_index, generation_state, position)
                node_op_states = dict()
                for assemble_op in assemble_inputs:
                    assemble_op(node_op_states)
                op_return = node_op(node_op_states) * self.training_variable * pruning_training_var
                tf.debugging.check_numerics(op_return, "Node result had invalid data")
                self.emitted_value = op_return
        else:
            def emit_node_value():
                node_op_states = dict()
                for assemble_op in assemble_inputs:
                    assemble_op(node_op_states)
                op_return = node_op(node_op_states)
                tf.debugging.check_numerics(op_return, "Node result had invalid data")
                self.emitted_value = op_return

        return emit_node_value

    def serialize(self):
        return (f"{{" +
                ", ".join([
                    f"id: {self.index}",
                    f"edges: {[[field_index, [edge.index for edge in edge_array]] for field_index, edge_array in enumerate(self.edges)]}",
                    f"generation_data: {self.generation_data}"
                ]) +
                f"}}")

    def accumulate_revival(self):
        for edge_index, field_edges in enumerate(self.edges):
            if ((self.left_index == edge_index or
                    (-1 != self.right_index and self.right_index == edge_index))
                    and 0 == len([edge for edge in field_edges if edge.is_active])):
                reviving_edge = random.choice(field_edges)
                self.test_re_added.append(reviving_edge)
                yield reviving_edge
